

**DIPARTIMENTO DI INFORMATICA**

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Formal Methods course **-** final assignment

byeSPACE

A Haskell interpreter for a C-like language

**Professor**

Giovanni Pani

**Student**

Giovanni Federico Poli

Mat: 766577

**Academic year**

2021-2022

Pagina | 1





Table of contents

\1. Introduction

\2. Grammar

\3. How the interpreter is structured

\4. Arithmetic and Boolean parsers

\5. Commands

\6. Setup + Examples

Pagina | 2





**1. Introduction**

For this project has been build an interpreter based on the C-like language called

CiMPLE. CiMPLE is a visual programming language that tries to visually mimic

procedural languages like C/C++.

The idea is that C is a low-level programming language, thus whatever is

expressible in the language is close in the resulting CPU instruction the compiler

generates. CiMPLE stands for “C” “Simple”, meaning that is a simplified version

of language C. It was in fact used to teach children robotics.

So, the focus of this project is to build an interpreter for this language (enriching

it with the ability to handle arrays and the ternary operator), which is able to

parse its instructions and execute them, always keeping track of an environment

in which is saved every variable involved in the process.

CiMPLE allows the use of some typical constructs of imperative languages, such

as assignment, if-then-else and while. More specifically, the language allows the

following defined operations:

· **Arithmetic expressions**: a0 + a1 | a0 – a1 | a0 \* a1 | a0 / a1

· **Boolean Expressions**: True | False | b0 < b1 | b0 == b1 | b0 > b1 | b0 >=

b1<= b1 | b0 != b1 | !b0 | b0 && b1 | b0 || b1

· **Commands**: skip | X = a0 | if b0 then c0 else c1 | while b do c |

Pagina | 3





**2. Grammar**

Let’s now formally define the grammar of the language using the BNF.

*Arithmetic Expressions:*

<**aexp**> ::= <aterm> '+' <aexp> | <aterm> '-' <aexp> | <aterm>

<**aterm**> ::= <factor> '\*' <aterm> | <factor> '/' <aterm> | <aterm>

<**factor**> ::= <identifier> | <integer> | '(' <aexp> ')' | <identifier> ‘{‘ <aexp> ‘}’

<**identifier**> ::= <lower> <alphaNum>

<**alphaNum**> ::= <lower> <alphaNum> | <upper> <alphaNum | <lower> | <upper>

<**lower**> ::= a-z

<**upper**> ::= A-Z

<**integer**> ::= '-' <natural> | <natural>

<**natural**> ::= <digit> <natural> | <digit>

<**digit**> ::= 0-9

<**concArray**> ::= <array> ‘++’ <array>

<**array**> ::= ‘{‘ <arrayItems> ‘}’ | <identifier>

<**arrayItems**> ::= <aexp> ‘,’ <arrayItems> | <aexp>

*Boolean Expressions:*

<**bexp**> ::= <bterm> 'OR' <bexp> | <bterm>

<**bterm**> ::= <bfactor> 'AND' <bterm> | <bfactor>

<**bfactor**> ::= 'False' | 'True' | '!'<bfactor> | '(' <bexp> ')' | <bcomparison>

<**bterm**> ::= 'False' | 'True' | '!'<bterm> | '(' <bexp>' )' | <bcomparison>

<**bcomparison**> ::= <aexp> '==' <aexp> | <aexp> '<=' <aexp> | <aexp> '>=' <aexp> |<aexp> '>' <aexp> |

<aexp> '<' <aexp>

*Commands:*

<**program**> ::= <command> ‘;’ <program> | <command>

<**command**> ::= <assignment> | <ifThenElse> | <while> | 'skip'

<**assignment**> ::= <identifier> '=' <aexp> ';' | <identifier> ‘{‘ <aexp> ‘}’ ’=’ <aexp> ';' |

<identifier> ‘=’ <array> ';' | <identifier> ‘=’ <array> ‘++’ <array> ';' |

<identifier> ‘{‘ <aexp> ‘}’ ‘=’ <identifier> ‘{‘ <aexp> ‘}’ ';' |

<identifier> ‘{‘ <identifier> ‘{‘ <aexp> ‘}’ ';'

<**ifThenElse**> ::= 'if' <bexp> 'then' <program> 'else' <program> ‘endif;'

<**while**> ::= 'while' <bexp> 'do' <program> ‘end’ ';'

<**ternary**> ::= ‘(’ <bexp> ‘)’ ‘=’ <program> ‘:’ <program>

Pagina | 4





**3. How the interpreter is structured**

We can identify two main components in the system:

the parser and the evaluator.

The **Parser** that takes a string in input and syntactically validate it. The Parser analyzes

each token of the input string and builds a tree that makes the syntactic structure of

the string explicit. It is able therefore to recognize the Arithmetic or Boolean

expressions and the Commands of the language.

The **Evaluator** has to execute the instructions based on the tree generated by the

Parser. The evaluator thus must read and write the Environment, which is the set of

local Variables necessary for the program, so it takes in input the formalized structure

given by the Parser and returns an updated Environment.

The evaluator performs an EAGER evaluation (call-by-value), meaning that evaluates

expressions in the exact moment in which they are assigned to a variable or when they

are arguments of functions or other expressions.

Let’s now talk about their implementation:

**Parser Implementation:**

First of all: what is a parser?

“*A parser for things is a function from strings*

*to lists of pairs of things and strings*”

At the most basic level, a parser takes a string in input and tries to recognize some

kind of structure in the form of a tree.

Making some adjustments to the initial definition we can say that a Parser can be

defined as a function that takes as input and produces a result of a generic type in

output. In particular, it returns a list composed by the part of the string it has parsed

or consumed and the rest of the string (which if it succeeds it’s just nothing, but the

parser does not always consume the entire given string, for this reason it’s

necessary to return the unconsumed part as output).

For our purposes though, we can’t really define our parser like this:

type Parser a = String -> [(a, string)] 

and that’s because we need to keep track of the changes that happen during the

execution of our program. Thus, we have to further modify our definition by adding

as input and output our Environment:

The final definition of the Parser is the following:

newtype Parser a = P (Env -> String -> [(Env,a,String)]) 

Pagina | 5





Using newtype allows us to make the type-constructor an instance of Functor,

Monad, Alternative and Applicative classes in Haskell in order to take advantage of

some useful operators.

· **Functor Parser** -> grants us the application of a function to the result of a Parser if

it succeeds, otherwise propagating the failure.

· **Applicative Parser** -> allows the concat. of different parsers with the operator.

· **The Monad Parser** p >>= f :

if the application of the parser p to the input string inp returns a value v,

then it applies the function f to v, and then apply the parser f v to the original

output string out and returns the result.

· **Alternative Parser** -> simulates choices between parsers; in particular:

if the first parser succeeds returns its output,

otherwise it applies the same input to the second parser.

Pagina | 6





**Environment Implementation:**

We need to define our Environment in order to implement effectively our Parser,

but what is an Environment?

Well, we cand imagine our Environment as the memory that needs to be updated

along the program execution.

It can be described as a list of elements of type Variable (which contains it name,

type and value).

So, it is necessary to define some functions in order to be able to read and write

from/on the Environment, such as:

\-

updateEnv -> which is self-explanatory, it updates the current environment and

if it finds a variable with the same name already in the Environment, it overrides

it with the new value using the function modifyEnv. 

\-

searchVariable and readVariable -> are useful to search a variable

with a given name and return its value.  

The same logic is also applied to arrays with the functions:

\-

\-

\-

\-

saveArray 

updateArray 

searchArray 

readArray 

With these functions we’re enhancing the base version of the language, endowing it

with some new functionalities useful in order to handle arrays.

In specific, our interpreter can manage arrays of integers defining them, assigning

them some values, indexing them, and concatenating them together as follows:

Assignment:



x={1,2,3} 

Once we assigned some values to the array variable, we can access its values using

the index

`                            `y=x{1} 

The index of an array can be the result of an Arithmetic expression:

x {1 + 1} = 2 

the array can be copied into another variable:

y = x 

and then we can also concatenate arrays:

z = x ++ y 

For instance, if x={1,2} and y={3,4}, z = {1,2,3,4}

Pagina | 7





Pagina | 8





**4. Arithmetic and Boolean Parsers**

**Note:**

in the following code I’ve decided to give spaces the optionality property, (by

which the name byeSPACE) meaning that:

it does not matter how many, if any, spaces you put into the input string of the

interpreter, it will always be able to recognize it as long as it respects the

correct syntax.

For these parsers we use the same logic, which implies a sub-division in 3

parsers, for instance in the Arithmetic Parser we have:

\- aexp -> manages addition and subtraction 

\- aterm -> manages multiplication between a factor and an aterm

\- factor -> manages the recursion 

Pagina | 9





The same can be said for the Boolean Parser, in which we have bexp, bterm,

bfactor and also bcomparison that, as before, allow us to define a priority

between operations:

Pagina | 10





**5. Commands**

The program Parser is defined recursively as a sequence of specified commands,

which are:

\- **assignment**

\- **ifThenElse** (in which can be specified only the “if” statement if there is no

“else” statement)

\- **while**

\- **ternary**

\- **skip**

Pagina | 11





**6. Setup + Examples**

byeSPACE has a command line interface that allows see the actual status of the

memory (our Environment) and how it has changed. It needs ghci in order to work

properly, so make sure it is installed and make also sure that the PATH of ghci is in

the list of System Variables.

To run byeSPACE with ghci you can open the terminal and navigate to the

byeSPACE.hs directory and then use the command: stack ghci byeSPACE.hs.

Then just call the function logo or menu, and then you can start writing your input

string in which you can put as many spaces as you like.

Let’s try to calculate the factorial of 5:

Pagina | 12





Let’s try the ternary operator:

Let’s try some array assignments and concatenation:

Let’s try to compute a Fibonacci sequence for n=6:

Pagina | 13





Pagina | 14

